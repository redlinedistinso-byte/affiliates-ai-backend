# affiliates_ai_backend/main.py
\"\"\"FastAPI prototype for Affiliates AI Backend
(Generated by assistant - edit secrets and STUBs before production)
\"\"\"
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from sqlmodel import Field, SQLModel, create_engine, Session, select
from typing import Optional, List
from pydantic import BaseModel
from apscheduler.schedulers.background import BackgroundScheduler
import os
import httpx
import openai
import datetime
import uuid

from dotenv import load_dotenv
load_dotenv()

OPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")
CLICKBANK_API_KEY = os.getenv(\"CLICKBANK_API_KEY\")
HOTMART_API_KEY = os.getenv(\"HOTMART_API_KEY\")
DATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///./data.db\")
ADMIN_API_KEY = os.getenv(\"ADMIN_API_KEY\", \"admin-secret\")

if OPENAI_API_KEY:
    openai.api_key = OPENAI_API_KEY

app = FastAPI(title=\"Affiliates AI Backend - Prototype\")

app.add_middleware(
    CORSMiddleware,
    allow_origins=[\"*\"],
    allow_credentials=True,
    allow_methods=[\"*\"],
    allow_headers=[\"*\"],
)

class Product(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    source: str
    source_id: str
    title: str
    description: Optional[str]
    image_url: Optional[str]
    price: Optional[str]
    currency: Optional[str]
    tags: Optional[str]
    last_synced: Optional[datetime.datetime]

class Ad(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    product_id: int
    content_json: Optional[str]
    scheduled_at: Optional[datetime.datetime]
    posted_at: Optional[datetime.datetime]
    status: Optional[str]

engine = create_engine(DATABASE_URL, echo=False)
SQLModel.metadata.create_all(engine)

class ConnectRequest(BaseModel):
    api_key: str
    secret: Optional[str]

class GenerateAdRequest(BaseModel):
    product_id: int
    language: Optional[str] = \"pt\"

async def admin_auth(x_api_key: str = Header(...)):
    if x_api_key != ADMIN_API_KEY:
        raise HTTPException(status_code=403, detail=\"Forbidden\")

async def fetch_clickbank_products() -> List[dict]:
    # STUB: implement ClickBank API calls here
    return [
        {\"source\":\"clickbank\", \"source_id\":\"cb-001\", \"title\":\"Produto CB Exemplo\", \"description\":\"Curso X\", \"image_url\":\"\", \"price\":\"49.99\", \"currency\":\"USD\"}
    ]

async def fetch_hotmart_products() -> List[dict]:
    # STUB: implement Hotmart API calls here
    return [
        {\"source\":\"hotmart\", \"source_id\":\"hm-001\", \"title\":\"Produto HM Exemplo\", \"description\":\"Curso Y\", \"image_url\":\"\", \"price\":\"39.99\", \"currency\":\"BRL\"}
    ]

def save_products(products: List[dict]):
    with Session(engine) as session:
        for p in products:
            stmt = select(Product).where(Product.source == p.get(\"source\"), Product.source_id == p.get(\"source_id\"))
            existing = session.exec(stmt).first()
            if existing:
                existing.title = p.get(\"title\")
                existing.description = p.get(\"description\")
                existing.image_url = p.get(\"image_url\")
                existing.price = p.get(\"price\")
                existing.currency = p.get(\"currency\")
                existing.last_synced = datetime.datetime.utcnow()
                session.add(existing)
            else:
                prod = Product(
                    source=p.get(\"source\"),
                    source_id=p.get(\"source_id\"),
                    title=p.get(\"title\"),
                    description=p.get(\"description\"),
                    image_url=p.get(\"image_url\"),
                    price=p.get(\"price\"),
                    currency=p.get(\"currency\"),
                    last_synced=datetime.datetime.utcnow()
                )
                session.add(prod)
        session.commit()

async def generate_ad_with_openai(product: Product, language: str = \"pt\") -> dict:
    prompt = f\"Você é um especialista em copywriting. Gere 3 títulos curtos, 3 scripts de 15s e 3 legendas para este produto:\\nTitle: {product.title}\\nDescription: {product.description or ''}\\nLanguage: {language}\\nRetorne JSON com chaves: titles, scripts, captions, hashtags, thumbnail_text.\"
    try:
        if not OPENAI_API_KEY:
            return {\"error\":\"OpenAI key not configured\"}
        resp = openai.ChatCompletion.create(
            model=\"gpt-4o-mini\",
            messages=[{\"role\":\"system\",\"content\":\"Você é um assistente de marketing.\"},{\"role\":\"user\",\"content\":prompt}],
            max_tokens=500,
            temperature=0.7
        )
        text = resp['choices'][0]['message']['content']
        import json
        parsed = json.loads(text)
        return parsed
    except Exception as e:
        return {\"error\":str(e)}

@app.get(\"/health\")
async def health():
    return {\"status\":\"ok\"}

@app.post(\"/connect/clickbank\")
async def connect_clickbank(req: ConnectRequest, x_api_key: str = Depends(admin_auth)):
    return {\"status\":\"connected_clickbank\"}

@app.post(\"/connect/hotmart\")
async def connect_hotmart(req: ConnectRequest, x_api_key: str = Depends(admin_auth)):
    return {\"status\":\"connected_hotmart\"}

@app.post(\"/sync\", dependencies=[Depends(admin_auth)])
async def sync_products(background_tasks: BackgroundTasks):
    background_tasks.add_task(_sync_job)
    return {\"status\":\"sync_started\"}

async def _sync_job():
    clickbank = await fetch_clickbank_products()
    hotmart = await fetch_hotmart_products()
    allp = clickbank + hotmart
    save_products(allp)

@app.get(\"/products\", response_model=List[Product])
async def list_products():
    with Session(engine) as session:
        prods = session.exec(select(Product)).all()
        return prods

@app.post(\"/ads/generate\", dependencies=[Depends(admin_auth)])
async def generate_ad(req: GenerateAdRequest):
    with Session(engine) as session:
        prod = session.get(Product, req.product_id)
        if not prod:
            raise HTTPException(status_code=404, detail=\"Product not found\")
        result = await generate_ad_with_openai(prod, req.language)
        ad = Ad(product_id=prod.id, content_json=str(result), scheduled_at=datetime.datetime.utcnow(), status=\"generated\")
        session.add(ad)
        session.commit()
        return {\"status\":\"generated\",\"ad\":result}

scheduler = BackgroundScheduler()

def daily_generation_job():
    print(\"Running daily generation job: \", datetime.datetime.utcnow())
    with Session(engine) as session:
        prods = session.exec(select(Product)).all()
        for p in prods:
            try:
                import asyncio
                loop = asyncio.get_event_loop()
                result = loop.run_until_complete(generate_ad_with_openai(p, \"pt\"))
                ad = Ad(product_id=p.id, content_json=str(result), scheduled_at=datetime.datetime.utcnow(), status=\"generated\")
                session.add(ad)
                session.commit()
            except Exception as e:
                print(\"Error generating ad for product\", p.id, e)

scheduler.add_job(daily_generation_job, 'cron', hour=8, minute=0)
scheduler.start()

@app.get(\"/ads\", response_model=List[Ad])
async def list_ads():
    with Session(engine) as session:
        ads = session.exec(select(Ad)).all()
        return ads

@app.post(\"/ads/{ad_id}/publish\", dependencies=[Depends(admin_auth)])
async def publish_ad(ad_id: int):
    with Session(engine) as session:
        ad = session.get(Ad, ad_id)
        if not ad:
            raise HTTPException(status_code=404, detail=\"Ad not found\")
        ad.status = \"posted\"
        ad.posted_at = datetime.datetime.utcnow()
        session.add(ad)
        session.commit()
        return {\"status\":\"posted\",\"ad_id\":ad_id}

@app.get(\"/\")
async def root():
    return {\"message\":\"Affiliates AI Backend running\"}

if __name__ == \"__main__\":
    import uvicorn
    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000, reload=True)
